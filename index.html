<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ottoman Temporal Clock — Saat-i Osmanî</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Crimson+Pro:ital,wght@0,300;0,400;1,300&display=swap" rel="stylesheet">
<style>
  :root {
    --gold: #C9A84C;
    --gold-light: #E8C97A;
    --gold-dim: #7A6030;
    --deep: #0D0A05;
    --panel: #1A1208;
    --turquoise: #2A7A7A;
    --turq-light: #4ABFBF;
    --crimson: #8B1A1A;
    --cream: #F5EDD6;
    --text: #E8D9B0;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--deep);
    color: var(--text);
    font-family: 'Crimson Pro', serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow-x: hidden;
    background-image: 
      radial-gradient(ellipse at 50% 0%, rgba(201,168,76,0.08) 0%, transparent 60%),
      repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(201,168,76,0.015) 35px, rgba(201,168,76,0.015) 70px);
  }

  header {
    text-align: center;
    margin-bottom: 2rem;
    position: relative;
  }

  header h1 {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(1rem, 3vw, 1.6rem);
    color: var(--gold);
    letter-spacing: 0.25em;
    text-shadow: 0 0 30px rgba(201,168,76,0.4);
  }

  header .sub {
    font-size: 0.85rem;
    color: var(--gold-dim);
    letter-spacing: 0.4em;
    margin-top: 0.3rem;
    font-style: italic;
  }

  .ornament {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    margin: 0.5rem 0;
    color: var(--gold-dim);
    font-size: 1.2rem;
  }
  .ornament::before, .ornament::after {
    content: '';
    height: 1px;
    width: 80px;
    background: linear-gradient(90deg, transparent, var(--gold-dim));
  }
  .ornament::after { background: linear-gradient(90deg, var(--gold-dim), transparent); }

  .clock-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas#clockFace {
    filter: drop-shadow(0 0 40px rgba(201,168,76,0.2));
  }

  .info-panel {
    display: flex;
    gap: 2rem;
    margin-top: 2rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .info-card {
    background: var(--panel);
    border: 1px solid var(--gold-dim);
    padding: 1rem 1.5rem;
    min-width: 160px;
    text-align: center;
    position: relative;
  }

  .info-card::before, .info-card::after {
    content: '◆';
    position: absolute;
    color: var(--gold);
    font-size: 0.5rem;
  }
  .info-card::before { top: 4px; left: 6px; }
  .info-card::after { bottom: 4px; right: 6px; }

  .info-card .label {
    font-size: 0.65rem;
    letter-spacing: 0.3em;
    color: var(--gold-dim);
    text-transform: uppercase;
    margin-bottom: 0.3rem;
  }

  .info-card .value {
    font-size: 1.4rem;
    color: var(--gold-light);
    font-family: 'Cinzel Decorative', serif;
  }

  .info-card .detail {
    font-size: 0.75rem;
    color: #8a7a5a;
    margin-top: 0.2rem;
    font-style: italic;
  }

  .location-bar {
    margin-top: 1.5rem;
    text-align: center;
    font-size: 0.7rem;
    letter-spacing: 0.35em;
    color: var(--gold-dim);
  }

  /* Abjad numerals mapping */
</style>
</head>
<body>

<header>
  <div class="ornament">✦</div>
  <h1>Saat-i Osmanî</h1>
  <p class="sub">The Ottoman Temporal Hour</p>
  <div class="ornament">✦</div>
</header>

<div class="clock-container">
  <canvas id="clockFace" width="520" height="520"></canvas>
</div>

<div class="info-panel">
  <div class="info-card">
    <div class="label">Ottoman Hour</div>
    <div class="value" id="ottomanHour">—</div>
    <div class="detail" id="periodName">—</div>
  </div>
  <div class="info-card">
    <div class="label">Hour Length</div>
    <div class="value" id="hourLength">—</div>
    <div class="detail">minutes</div>
  </div>
  <div class="info-card">
    <div class="label">Sunrise</div>
    <div class="value" id="sunriseTime">—</div>
    <div class="detail" id="sunsetLabel">Sunset: —</div>
  </div>
</div>

<div class="location-bar" id="locationBar">Acquiring position…</div>

<script>
// ─── Sun calculation ───────────────────────────────────────────────────────
function sunTimes(date, lat, lon) {
  // Use the NOAA/Wikipedia algorithm anchored entirely in UTC Julian days
  // so timezone never contaminates the arithmetic.
  const JD = date.getTime() / 86400000 + 2440587.5;

  // Julian day number for noon UTC on the given date
  const Jdate = Math.floor(JD) + 0.5;
  const n = Jdate - 2451545.0;

  // Solar mean anomaly (deg)
  const M_deg = (357.5291 + 0.98560028 * n) % 360;
  const M = M_deg * Math.PI / 180;

  // Equation of centre (deg)
  const C = 1.9148 * Math.sin(M) + 0.0200 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M);

  // Ecliptic longitude (deg)
  const lambda_deg = (M_deg + C + 180 + 102.9372) % 360;
  const lambda = lambda_deg * Math.PI / 180;

  // Solar transit (Julian day, UTC)
  const Jnoon = 2451545.0 + 0.0009 + ((-lon) / 360) + n
              + 0.0053 * Math.sin(M)
              - 0.0069 * Math.sin(2 * lambda);

  // Declination
  const sinDec = Math.sin(lambda) * Math.sin(23.4397 * Math.PI / 180);
  const dec = Math.asin(sinDec);

  // Hour angle
  const latR = lat * Math.PI / 180;
  const cosH = (Math.sin(-0.8333 * Math.PI / 180) - Math.sin(latR) * sinDec)
             / (Math.cos(latR) * Math.cos(dec));
  if (cosH > 1 || cosH < -1) return null;
  const H_deg = Math.acos(cosH) * 180 / Math.PI;

  // Rise/set as Julian days (UTC), convert to JS Date
  const toMs = jd => (jd - 2440587.5) * 86400000;
  return {
    rise: new Date(toMs(Jnoon - H_deg / 360)),
    set:  new Date(toMs(Jnoon + H_deg / 360)),
  };
}

// ─── Abjad numerals (eastern arabic) ─────────────────────────────────────
const arabicNumerals = ['٠','١','٢','٣','٤','٥','٦','٧','٨','٩'];
function toArabic(n) {
  return String(n).split('').map(d => arabicNumerals[parseInt(d)]).join('');
}

// Ottoman hour labels 1–12 (eastern arabic)
const hourLabels = Array.from({length: 12}, (_, i) => toArabic(i + 1));

// ─── State ─────────────────────────────────────────────────────────────────
let lat = 41.0082, lon = 28.9784; // Default: Istanbul
let locationName = 'Istanbul';

// ─── Canvas drawing ────────────────────────────────────────────────────────
const canvas = document.getElementById('clockFace');
const ctx = canvas.getContext('2d');
const CX = canvas.width / 2, CY = canvas.height / 2;
const R = 230;

function fmtTime(d) {
  return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}

function drawClock() {
  const now = new Date();
  const times = sunTimes(now, lat, lon);
  if (!times) return;

  const riseMs = times.rise.getTime();
  const setMs  = times.set.getTime();
  const nowMs  = now.getTime();

  const dayDur   = setMs - riseMs;
  const nightDur = 86400000 - dayDur;
  const dayHour   = dayDur / 12;
  const nightHour = nightDur / 12;

  // Determine current Ottoman hour and progress
  let ottHour, progress, isDaytime;
  if (nowMs >= riseMs && nowMs < setMs) {
    isDaytime = true;
    const elapsed = nowMs - riseMs;
    ottHour = Math.floor(elapsed / dayHour) + 1;
    progress = (elapsed % dayHour) / dayHour;
  } else {
    isDaytime = false;
    let nightElapsed = nowMs >= setMs ? nowMs - setMs : nowMs + 86400000 - setMs;
    ottHour = Math.floor(nightElapsed / nightHour) + 1;
    progress = (nightElapsed % nightHour) / nightHour;
  }

  // ── Background ──────────────────────────────────────────────────────────
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Outer bezel
  const bezelGrad = ctx.createRadialGradient(CX, CY, R - 10, CX, CY, R + 18);
  bezelGrad.addColorStop(0, '#3D2E10');
  bezelGrad.addColorStop(0.5, '#C9A84C');
  bezelGrad.addColorStop(1, '#3D2E10');
  ctx.beginPath();
  ctx.arc(CX, CY, R + 18, 0, Math.PI * 2);
  ctx.fillStyle = bezelGrad;
  ctx.fill();

  // Decorative bezel ring pattern
  for (let i = 0; i < 72; i++) {
    const a = (i / 72) * Math.PI * 2 - Math.PI / 2;
    const r1 = R + 8, r2 = R + 16;
    ctx.beginPath();
    ctx.moveTo(CX + r1 * Math.cos(a), CY + r1 * Math.sin(a));
    ctx.lineTo(CX + r2 * Math.cos(a), CY + r2 * Math.sin(a));
    ctx.strokeStyle = i % 6 === 0 ? '#FFE08A' : 'rgba(201,168,76,0.3)';
    ctx.lineWidth = i % 6 === 0 ? 2 : 0.7;
    ctx.stroke();
  }

  // Clock face background
  const faceGrad = ctx.createRadialGradient(CX - 40, CY - 40, 10, CX, CY, R);
  faceGrad.addColorStop(0, '#2A1E08');
  faceGrad.addColorStop(1, '#0D0A05');
  ctx.beginPath();
  ctx.arc(CX, CY, R, 0, Math.PI * 2);
  ctx.fillStyle = faceGrad;
  ctx.fill();

  // ── Draw 24 segments (12 day, 12 night) ────────────────────────────────
  // We'll map the clock face: top = sunrise (12 o'clock), going clockwise
  // Daytime arc = proportional to day length, nighttime = rest

  const dayFraction = dayDur / 86400000;
  const nightFraction = 1 - dayFraction;
  const dayAngle = dayFraction * Math.PI * 2;
  const nightAngle = nightFraction * Math.PI * 2;

  const startAngle = -Math.PI / 2; // 12 o'clock = sunrise

  // Draw day segments
  for (let i = 0; i < 12; i++) {
    const segStart = startAngle + i * (dayAngle / 12);
    const segEnd   = startAngle + (i + 1) * (dayAngle / 12);
    const isActive = isDaytime && (i + 1 === ottHour);

    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.arc(CX, CY, R - 2, segStart, segEnd);
    ctx.closePath();

    const gradient = ctx.createRadialGradient(CX, CY, 0, CX, CY, R);
    if (isActive) {
      gradient.addColorStop(0, 'rgba(230,180,80,0.35)');
      gradient.addColorStop(1, 'rgba(180,130,40,0.5)');
    } else if (isDaytime && i + 1 < ottHour) {
      gradient.addColorStop(0, 'rgba(120,90,20,0.2)');
      gradient.addColorStop(1, 'rgba(100,70,10,0.3)');
    } else {
      gradient.addColorStop(0, 'rgba(60,45,10,0.1)');
      gradient.addColorStop(1, 'rgba(40,30,5,0.2)');
    }
    ctx.fillStyle = gradient;
    ctx.fill();

    // Segment border
    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.arc(CX, CY, R - 2, segStart, segEnd);
    ctx.closePath();
    ctx.strokeStyle = isActive ? 'rgba(255,220,100,0.7)' : 'rgba(150,110,30,0.4)';
    ctx.lineWidth = isActive ? 1.5 : 0.8;
    ctx.stroke();
  }

  // Draw night segments
  const nightStart = startAngle + dayAngle;
  for (let i = 0; i < 12; i++) {
    const segStart = nightStart + i * (nightAngle / 12);
    const segEnd   = nightStart + (i + 1) * (nightAngle / 12);
    const isActive = !isDaytime && (i + 1 === ottHour);

    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.arc(CX, CY, R - 2, segStart, segEnd);
    ctx.closePath();

    const gradient = ctx.createRadialGradient(CX, CY, 0, CX, CY, R);
    if (isActive) {
      gradient.addColorStop(0, 'rgba(40,120,140,0.4)');
      gradient.addColorStop(1, 'rgba(20,80,100,0.55)');
    } else if (!isDaytime && i + 1 < ottHour) {
      gradient.addColorStop(0, 'rgba(15,50,70,0.25)');
      gradient.addColorStop(1, 'rgba(10,35,50,0.3)');
    } else {
      gradient.addColorStop(0, 'rgba(5,20,30,0.1)');
      gradient.addColorStop(1, 'rgba(5,15,25,0.2)');
    }
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.arc(CX, CY, R - 2, segStart, segEnd);
    ctx.closePath();
    ctx.strokeStyle = isActive ? 'rgba(80,200,220,0.6)' : 'rgba(30,80,100,0.4)';
    ctx.lineWidth = isActive ? 1.5 : 0.8;
    ctx.stroke();
  }

  // ── Transition markers (sunrise / sunset) ──────────────────────────────
  const markerAngles = [startAngle, startAngle + dayAngle];
  const markerLabels = ['Sunrise', 'Sunset'];
  markerAngles.forEach((a, mi) => {
    ctx.beginPath();
    ctx.moveTo(CX + (R - 40) * Math.cos(a), CY + (R - 40) * Math.sin(a));
    ctx.lineTo(CX + R * Math.cos(a), CY + R * Math.sin(a));
    ctx.strokeStyle = mi === 0 ? '#E8C97A' : '#FF8844';
    ctx.lineWidth = 2.5;
    ctx.stroke();

    // Label
    const lx = CX + (R + 28) * Math.cos(a);
    const ly = CY + (R + 28) * Math.sin(a);
    ctx.save();
    ctx.font = 'italic 10px "Crimson Pro", serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = mi === 0 ? 'rgba(232,201,122,0.85)' : 'rgba(255,136,68,0.85)';
    ctx.translate(lx, ly);
    ctx.rotate(a + Math.PI / 2);
    ctx.fillText(markerLabels[mi].toUpperCase(), 0, 0);
    ctx.restore();
  });

  // ── Outer ring hour labels ──────────────────────────────────────────────
  // Day labels
  ctx.font = 'bold 13px serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for (let i = 0; i < 12; i++) {
    const midAngle = startAngle + (i + 0.5) * (dayAngle / 12);
    const lx = CX + (R - 22) * Math.cos(midAngle);
    const ly = CY + (R - 22) * Math.sin(midAngle);
    const isActive = isDaytime && (i + 1 === ottHour);
    ctx.fillStyle = isActive ? '#FFE08A' : 'rgba(201,168,76,0.55)';
    ctx.font = isActive ? 'bold 14px serif' : '12px serif';
    ctx.fillText(hourLabels[i], lx, ly);
  }

  // Night labels
  for (let i = 0; i < 12; i++) {
    const midAngle = nightStart + (i + 0.5) * (nightAngle / 12);
    const lx = CX + (R - 22) * Math.cos(midAngle);
    const ly = CY + (R - 22) * Math.sin(midAngle);
    const isActive = !isDaytime && (i + 1 === ottHour);
    ctx.fillStyle = isActive ? '#80DFFF' : 'rgba(74,191,191,0.4)';
    ctx.font = isActive ? 'bold 14px serif' : '12px serif';
    ctx.fillText(hourLabels[i], lx, ly);
  }

  // ── Inner decorative ring ───────────────────────────────────────────────
  ctx.beginPath();
  ctx.arc(CX, CY, R - 38, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(201,168,76,0.25)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // ── Arabesque center ornament ───────────────────────────────────────────
  // Draw decorative star
  drawStar(CX, CY, 8, 38, 18, 'rgba(201,168,76,0.15)', '#C9A84C', 0.6);

  // ── Clock hand ─────────────────────────────────────────────────────────
  // Ottoman clocks reset at sunset. Hand points to current angle in the 24h cycle.
  let handAngle;
  if (isDaytime) {
    const elapsed = nowMs - riseMs;
    handAngle = startAngle + (elapsed / 86400000) * Math.PI * 2;
  } else {
    let nightElapsed = nowMs >= setMs ? nowMs - setMs : nowMs + 86400000 - setMs;
    handAngle = startAngle + dayAngle + (nightElapsed / 86400000) * Math.PI * 2;
  }

  // Hand shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.6)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;

  // Minute progress indicator (thin secondary hand within segment)
  const segStart2 = isDaytime
    ? startAngle + (ottHour - 1) * (dayAngle / 12)
    : nightStart + (ottHour - 1) * (nightAngle / 12);
  const segEnd2   = isDaytime
    ? startAngle + ottHour * (dayAngle / 12)
    : nightStart + ottHour * (nightAngle / 12);
  const progressAngle = segStart2 + progress * (segEnd2 - segStart2);

  // Thin segment fill
  ctx.beginPath();
  ctx.moveTo(CX, CY);
  ctx.arc(CX, CY, R - 42, segStart2, progressAngle);
  ctx.closePath();
  ctx.fillStyle = isDaytime ? 'rgba(255,200,60,0.2)' : 'rgba(60,180,220,0.2)';
  ctx.fill();

  // Main hand
  const handLen = R - 48;
  ctx.beginPath();
  ctx.moveTo(CX, CY);
  ctx.lineTo(CX + handLen * Math.cos(handAngle), CY + handLen * Math.sin(handAngle));
  ctx.strokeStyle = isDaytime ? '#FFD700' : '#4ABFBF';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.stroke();

  // Counter-weight
  ctx.beginPath();
  ctx.moveTo(CX, CY);
  ctx.lineTo(CX - 20 * Math.cos(handAngle), CY - 20 * Math.sin(handAngle));
  ctx.strokeStyle = isDaytime ? 'rgba(255,180,0,0.6)' : 'rgba(74,191,191,0.6)';
  ctx.lineWidth = 4;
  ctx.stroke();

  ctx.restore();

  // Center jewel
  const jewelGrad = ctx.createRadialGradient(CX - 2, CY - 2, 1, CX, CY, 9);
  jewelGrad.addColorStop(0, '#FFE08A');
  jewelGrad.addColorStop(0.6, '#C9A84C');
  jewelGrad.addColorStop(1, '#7A6030');
  ctx.beginPath();
  ctx.arc(CX, CY, 9, 0, Math.PI * 2);
  ctx.fillStyle = jewelGrad;
  ctx.fill();
  ctx.beginPath();
  ctx.arc(CX, CY, 9, 0, Math.PI * 2);
  ctx.strokeStyle = '#FFE08A';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // ── Day/Night arc labels ────────────────────────────────────────────────
  ctx.save();
  ctx.font = 'italic 10px "Crimson Pro", serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'rgba(232,201,122,0.45)';
  const dayMidAngle = startAngle + dayAngle / 2;
  ctx.fillText('DAYTIME', CX + (R + 30) * Math.cos(dayMidAngle), CY + (R + 30) * Math.sin(dayMidAngle));
  ctx.fillStyle = 'rgba(74,191,191,0.4)';
  const nightMidAngle = nightStart + nightAngle / 2;
  ctx.fillText('NIGHT', CX + (R + 30) * Math.cos(nightMidAngle), CY + (R + 30) * Math.sin(nightMidAngle));
  ctx.restore();

  // ── Update info panel ───────────────────────────────────────────────────
  document.getElementById('ottomanHour').textContent = toArabic(ottHour);
  document.getElementById('periodName').textContent = isDaytime ? 'Daytime Hour' : 'Nighttime Hour';
  const hourMinutes = Math.round((isDaytime ? dayHour : nightHour) / 60000);
  document.getElementById('hourLength').textContent = hourMinutes;
  document.getElementById('sunriseTime').textContent = fmtTime(times.rise);
  document.getElementById('sunsetLabel').textContent = `Sunset: ${fmtTime(times.set)}`;
}

function drawStar(cx, cy, points, outerR, innerR, fill, stroke, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  for (let i = 0; i < points * 2; i++) {
    const a = (i * Math.PI / points) - Math.PI / 2;
    const r = i % 2 === 0 ? outerR : innerR;
    if (i === 0) ctx.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
    else ctx.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
  }
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

// ── Geolocation ────────────────────────────────────────────────────────────
function init() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      lat = pos.coords.latitude;
      lon = pos.coords.longitude;
      // Reverse geocode with nominatim
      fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`)
        .then(r => r.json())
        .then(d => {
          locationName = d.address?.city || d.address?.town || d.address?.county || 'Your Location';
          document.getElementById('locationBar').textContent =
            `☽ ${locationName} · ${lat.toFixed(2)}°N ${lon.toFixed(2)}°E ☽`;
        }).catch(() => {});
    }, () => {
      document.getElementById('locationBar').textContent = '☽ Istanbul, Turkey (Default) ☽';
    });
  } else {
    document.getElementById('locationBar').textContent = '☽ Istanbul, Turkey (Default) ☽';
  }

  drawClock();
  setInterval(drawClock, 1000);
}

init();
</script>
</body>
</html>
